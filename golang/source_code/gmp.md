# Go语言源码分析之GPM调度器

Go 面试的万能题之 "**GMP 模型，为什么要有 P**？"进一步推敲问题的背后，其实这个面试题本质是想问："**GMP 模型，为什么不是 G 和 M 直接绑定就完了，还要搞多一个 P 出来，那么麻烦，为的是什么，是要解决什么问题吗**？"

带着些许疑惑往下看，首先，让我们看一下什么是GM模型：

## 1.GM模型是什么

<img src="https://raw.githubusercontent.com/zmk-c/blogImages/master/img/20210512164910.png" alt="image-20210512164910647" style="zoom:50%;" />

​																													GM图

在 `Go 1.1`版本之前，其实用的就是`GM`模型。

- **G**，协程(用户态的线程)。通常在代码里用  `go` 关键字执行一个方法，那么就等于起了一个`G`。
- **M**，**内核线程**，操作系统内核其实看不见`G`和`P`，只知道自己在执行一个线程。`G`和`P`都是在**用户层**上的实现。

除了`G`和`M`以外，还有一个**全局协程队列**，这个全局队列里放的是多个处于**可运行状态**的`G`。`M`如果想要获取`G`，就需要访问这个**全局队列**。同时，内核线程`M`是可以同时存在**多个**的，因此访问时还需要考虑**并发**安全问题。因此这个全局队列有一把**全局的大锁**，每次`M`访问`G`时都需要去获取这把大锁。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnnCNicPFSO8UrVpOetibsuuG23P8oL2pcUicqVKNCIMAakX36ib5CLZFjUcHeVmmdtyq31jQOMOfl4lUw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片" style="zoom:50%;" />

​																														GM模型

但是上述的GM模型实现有如下的问题：

- 存在单一的全局 mutex（Sched.Lock）和集中状态管理：

  - mutex 需要保护所有与 `G`相关的操作（创建、完成、重排等），导致锁竞争严重。

- `G` 传递的问题：

  - `G`交接（G.nextg）：`M`之间会经常交接可运行的 goroutine。

  - 上述可能会导致延迟增加和额外的开销。每个` M `必须能够执行任何可运行的` G`，特别是刚刚创建 `G` 的 `M`。

- 每个 `M` 都需要做内存缓存（M.mcache）：

  - 会导致资源消耗过大（每个 mcache 可以吸纳到 2M 的内存缓存和其他缓存），数据局部性差。

- 频繁的线程阻塞/解阻塞：

  - 在存在 syscalls 的情况下，线程经常被阻塞和解阻塞。这增加了很多额外的性能开销。


因此在2012年重新设计了Go调度器模型。

## 2.GMP模型是什么

<img src="https://raw.githubusercontent.com/zmk-c/blogImages/master/img/20210512164931.png" alt="image-20210512164931081" style="zoom:50%;" />

​																														GMP图

基于**没有什么是加一个中间层不能解决的**思路，`golang`在原有的`GM`模型的基础上加入了一个调度器`P`，可以简单理解为是在`G`和`M`中间加了个中间层。于是就有了现在的`GMP`模型。

<img src="https://raw.githubusercontent.com/zmk-c/blogImages/master/img/20210512164949.png" alt="image-20210512164949073" style="zoom:50%;" />

​																									GMP模型

1. **全局队列**（Global Queue）：存放等待运行的 `G`。
2. **P 的本地队列**：同全局队列类似，存放的也是等待运行的 `G`，存的数量有限，**不超过 256 个**。新建 `G’`时，`G’`优先加入到 P 的本地队列，如果队列满了，则会把**本地队列中一半的 G 移动到全局队列**。
3. **P 列表**：所有的` P` 都在程序启动时创建，并保存在数组中，最多有 **GOMAXPROCS(可配置)** 个。
4. **M**：线程想运行任务就得获取 `P`，从 P 的本地队列获取 `G`，访问本地队列不用加锁，当P 的本地队列为空时，`M` 也会尝试从全局队列拿一批`G` 放到 P 的本地队列，或从其他 P 的本地队列**偷一半（采用Work Stealing算法）**放到自己 P 的本地队列。`M` 运行 `G`，`G` 执行之后，`M` 会从 `P `获取下一个 `G`，不断重复下去。

Goroutine 调度器和 OS 调度器是通过 `M` 结合起来的，每个 `M` 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。

## 3.为什么P的逻辑不直接加在M上

如果是想实现本地队列、Work Stealing 算法，那**为什么不直接在 M 上加呢，M 也照样可以实现类似的功能**。

为什么又再加多一个 P 组件？

结合 `M`的定位来看，若这么做，有以下问题。

- 一般来讲，`M` 的数量都会多于 `P`。像在 golang 中，**M 的数量最大限制是 10000**，**P 的默认数量的 CPU 核数**。另外由于 M 的属性，也就是如果存在系统阻塞调用，阻塞了`M`，又不够用的情况下，`M` 会不断增加。
- `M `不断增加的话，如果本地队列挂载在 `M` 上，那就意味着本地队列也会随之增加。这显然是不合理的，因为本地队列的管理会变得复杂，且 Work Stealing 性能会大幅度下降。
- `M` 被系统调用阻塞后，我们是期望把他既有未执行的任务分配给其他继续运行的，而不是一阻塞就导致全部停止。

因此使用 M 是不合理的，那么引入新的组件 P，把本地队列关联到 P 上，就能很好的解决这个问题。

## 4.加入P带来的改变

现在可以回答开头提到的问题了：为什么要加 `P` 加了 `P` 之后会带来什么改变呢？我们再更显式的讲一下。

- 每个 `P` 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。
- 每个 `P` 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 `G` 来运行，减少空转，提高了资源利用率。

## 总结

一句话，**Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。**



> 参考:
>
> - [动图图解！GMP模型里为什么要有P？背后的原因让人暖心](https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ)
> - [典藏版 Golang 调度器 GMP 原理与调度全分析 | Go 技术论坛 ](https://learnku.com/articles/41728)
> - [再见 Go 面试官：GMP 模型，为什么要有 P？](https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw)