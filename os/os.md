# 操作系统

> 什么是操作系统？

我通过以下几点向您介绍一下什么是操作系统吧！

1. 操作系统（Operating System，简称 OS）**本质上是一个运行在计算机上的软件程序，用于管理计算机硬件与软件资源的程序**，是计算机的基石。举例~
2. **操作系统存在屏蔽了硬件层的复杂性。** 操作系统就像是硬件使用的负责人，统筹着各种相关事项。
3. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

![Kernel_Layout](https://raw.githubusercontent.com/zmk-c/blogImages/master/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png)

> 什么是系统调用呢？

介绍系统调用之前，我们先来了解一下用户态和系统态。

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

1. **用户态(user mode)** : 用户态运行的进程可以直接读取用户程序的数据。
2. **系统态(kernel mode)**：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

说了用户态和系统态之后，那么什么是系统调用呢？

**我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！**

也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

> 协程，线程和进程的区别以及进程的状态转换图

- **进程（process）**：进程可以说是一个“执行中的程序”。程序是指令、数据及其组织形式的描述，是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程，是**操作系统资源分配的最小单位**。类比各个连锁的物业公司~

- **线程（thread）**：是**操作系统能够进行运算调度的最小单位**，它被包含在进程之中，是进程中的实际运作单位。

  - **多线程共享资源**：共享一个进程提供的资源。类比于物业公司提供的工人的工具，工人就是线程，物业公司就是进程~
  - **线程冲突**：多个线程需要同一个资源。类比物业公司只有一把管钳，但是很多工人同时需要。解决线程冲突的办法有很多，比如排队等候，等其他工人用完，这个叫**线程同步**~
  - **线程参与**：主线程会监视其他线程的工作。类比如果某个工人的工作非常重要，你（主线程）也许会亲自监工一段时间，如果不指定时间，则表示你会一直监工到该项工作完成~

  在单核时，只能进行并发执行某个线程（操作系统的`时间片轮转法`是分配时间片给线程而不是进程）由于时间片轮转，虽然cpu中只有这一个线程在执行，可它还是每执行一个时间片后就被调度出cpu，再调度回来，这样时间被用来执行线程+调度线程，cpu一直在执行线程和调度，利用率为100%，此时如果增加线程，执行效率不会得到提升，反而可能因为**调度变复杂、内存等资源争夺而降低效率**！

- **协程（coroutine）**：是一种**用户态的轻量级线程**，协程的调度完全**由用户控制**。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
  协程在子程序内部可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。

  在Golong语言中，本质上goroutine 就是协程（官方给的goroutine内存大小为`2KB`）。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。

![image-20210723184854898](https://raw.githubusercontent.com/zmk-c/blogImages/master/img/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B.png)

我们一般把进程大致分为 5 种状态，如下图所示：

![image-20210723183935141](https://raw.githubusercontent.com/zmk-c/blogImages/master/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)

1. **创建状态**：进程在创建时需要申请一个空白`PCB`（进程管理块，存放进程的管理和控制信息的数据结构），向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态。
2. **就绪状态**：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行。
3. **运行状态**：进程处于就绪状态被调度后，进程进入执行状态。
4. **阻塞状态**：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用。
5. **终止状态**：进程结束，或出现错误，或被系统终止，进入终止状态，无法再执行。

> 进程间常见的通信方式

每个进程各自有**不同的用户地址空间**，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须**通过内核**，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信（IPC，InterProcess Communication）**

![img](https://raw.githubusercontent.com/zmk-c/blogImages/master/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.webp)

参考[《进程间通信 IPC (InterProcess Communication)》](https://www.jianshu.com/p/c1015f5ffa74) ，大概有 7 种常见的进程间的通信方式：

1. **管道/匿名管道(Pipes)** ：管道是半双工通信，用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。匿名管道存在于`内存中`。
2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以`磁盘文件`的方式存在，可以实现本机任意两个进程通信。
3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. **消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在`内核`中，只有在内核重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取，比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。**
5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。（**信号量在进程间是以有名信号量进行通信的**）
6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

> 线程间的同步方式

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以**保证公共资源不会被多个线程同时访问**。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它**允许同一时刻多个线程访问同一资源**，但是需要控制同一时刻访问此资源的最大线程数量。（**信号量在线程间是一般以无名信号量进行通信的**）
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

> 进程的调度算法

嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！

为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

> 什么是死锁？以及产生死锁的四个必要条件是什么？

多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。这种情况成为**死锁**。

如果系统中以下四个条件同时成立，那么就能引起死锁：

- **互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
- **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
- **非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
- **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。
